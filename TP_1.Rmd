Primero se cargan todas las librerias que se van a estar usando en el trabajo

```{r}
rm(list=ls())

library(lubridate)
library(ggplot2)
library(dplyr)
library('rmarkdown')
library(pwr)
library(boot)
library(plotly)
```
```{r}
options(scipen=999) #para evitar trabajar con notaci칩n cient칤fica
```

A continuacion se cargan los datos:

  - La base de recorridos de bicicletas durante el 2018
  - Los archivos de id_usuarios para los a침os 2015,2016,2017,2018

```{r}

setwd('C:/Users/elosasso/OneDrive - Universidad Torcuato Di Tella/Metodos estadisticos aplicados a negocios/TP1/MEAN_TP1')

df <- read.csv('recorridos-realizados-2018.csv')

users_2018 <- read.csv('usuarios-ecobici-2018.csv')
users_2017 <- read.csv('usuarios-ecobici-2017.csv')
users_2016 <- read.csv('usuarios-ecobici-2016.csv')
users_2015 <- read.csv('usuarios-ecobici-2015.csv')

users <- rbind(users_2018,users_2017,users_2016,users_2015)
```

```{r}

str(df)

```

Se ven algunas variables que se declararon mal el tipo: fecha_origen_recorrido, duracion_recorrido y fecha_destino_recorrido. Se cambian a sus tipos correspondientes

```{r}
df$fecha_origen_recorrido <- as.POSIXct(strptime(df$fecha_origen_recorrido, format = "%Y-%m-%d %H:%M:%OS",
                                      tz = "America/Argentina/Buenos_Aires"))

df$duracion_recorrido <- as.numeric(df$duracion_recorrido, units = 'secs') #Hay que verificar si estan bien calculadas!

df$fecha_destino_recorrido <- as.POSIXct(strptime(df$fecha_destino_recorrido, format = "%Y-%m-%d %H:%M:%OS",
                                      tz = "America/Argentina/Buenos_Aires"))
```
Siempre es de mucho provecho contar con datos de tipo fecha. Por eso se generan nuevas variables para obtener el d칤a, mes y la hora de la semana en la que se extrajeron las bicicletas.

```{r}
df$dia_de_semana_origen   <- wday(df$fecha_origen_recorrido, label = TRUE,
                              abbr = FALSE)
df$hora_del_dia_origen <- hour(df$fecha_origen_recorrido)

df$mes_de_origen <- month(df$fecha_origen_recorrido, label = TRUE,
                          abbr = FALSE)

```

```{r}
head(select(df,dia_de_semana_origen,hora_del_dia_origen,mes_de_origen))
```

Punto 1: An치lisis exploratorio
------------------------------

Se analizan algunos gr치ficos para entender la distribuci칩n de algunas m칠tricas como la edad, el uso de las bicicletas, frecuencia, lugares, etc. 

```{r}
boxplot(df$duracion_recorrido, xlab = 'Duracion del recorrido (seg)', main = 'Distribucion del tiempo de uso', horizontal = TRUE)
abline(v = median(df$duracion_recorrido), col = 'red', lty = 2)
```

Vemos que si bien existen outliers, lo normal es que una persona use una bicicleta hasta unos 3000/4000 segundos (~50 minutos/ 1 hora). Lo que tiene sentido porque es el tiempo permitido para cada recorrido.
La explicaci칩n para tiempos mayores puede deberse a que durante los fines de semana se permit칤a un uso de hasta 2 horas por recorrido.


Para entender si visualmente existe un horario en el que m치s se usen las bicicletas, se grafica la cantidad de extracciones por hora, para cada d칤a de la semana.

```{r}
ggplot(data = df) + geom_bar(mapping = aes(x = hora_del_dia_origen)) + facet_wrap(~ dia_de_semana_origen) + labs(x = 'Hora del d칤a') + ggtitle('Cantidad de extracciones por hora del d칤a, seg칰n el d칤a de la semana')
```

Se observa que en todos los d칤as existe un cierto 'patron' bastante com칰n. Los horarios picos son entre las 15:00 y las 20:00 horas, a partir de la cual baja el uso. Se observa un leve repunte en las primeras horas del d칤a, pero en general, entre la 1:00 y las 5:00 am son los horarios m치s tranquilos. 

Si bien tienen (aparentemente) el mismo comportamiento que durante los d칤as de semana, vemos que durante los fines de semana cae el uso.

Aprovechando que tenemos datos de fecha, observamos la cantidad de extracciones por mes.

```{r}
ggplot(data = df) + geom_bar(mapping = aes(y = mes_de_origen)) + labs(x = 'Cantidad de extracciones', y = 'Mes') + ggtitle('Cantidad de extracciones por mes')
```


Pareciera haber un mayor n칰mero de extracciones en los meses de agosto, septiembre y octubre, con un menor uso durante enero, febrero y marzo (podr칤a explicarse por las vacaciones?)

Otro dato interesante de obtener es la cantidad de extracciones por estaci칩n, para ver si hay alguna zona en particular con mayor movimiento, para eso creamos una tabla con las estaciones y sus ubicaciones, junto  con la cantidad de extracciones en cada una.


```{r}
mapa <- df %>% filter(complete.cases(lat_estacion_origen)) %>% group_by(nombre_estacion_origen, lat_estacion_origen, long_estacion_origen) %>% summarize(q = n()) %>% ungroup()
mapa
```

Visualizamos en un mapa:

```{r}

library(leaflet)

pal <- colorNumeric(c('blue','yellow','red'), domain = mapa$q)

m <- leaflet(data = mapa) %>% 
   addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(lng=mapa$long_estacion_origen, lat=mapa$lat_estacion_origen,
                   radius = 3,
                   col = ~pal(q),
                   stroke = FALSE,
                   fillOpacity = 0.8) %>%
  addLegend(pal = pal, values = ~q)
m  # Print the map

```

Se ve que pocas estaciones superan las 25 mil extracciones, pero si puede verse que en las zonas de once, almagro, villa cresto, palermo, existe un n칰mero mayor de extracciones.

Al mismo tiempo, las zonas de puerto madero y el sur de la capital poseen un menor n칰mero de extracciones.

**NOTA: Notar que no est치n todas las estaciones que uno esperar칤a, esto fue porque muchos registros ten칤an NAs en sus valores de latitud y longitud, por lo que no pudieron ubicarse.**

Para poder analizar los casos de los recorridos entre las estaciones Parque las heras y Billingurst primero verificamos qu칠 tan com칰n es el recorrido.

```{r}

df$misma_estacion <- df$nombre_estacion_origen == df$nombre_estacion_destino

bicis = as.data.frame(df)

bicis %>% filter((!is.na(id_estacion_origen)) & (!is.na(id_estacion_destino)) & (misma_estacion == FALSE)) %>% 
  group_by(nombre_estacion_origen,nombre_estacion_destino) %>%  
  summarize(count = n()) %>% arrange(desc(count)) %>% ungroup()

bicis %>% filter((id_estacion_origen == 009) & (id_estacion_destino == 066)) %>% select(nombre_estacion_origen,nombre_estacion_destino) %>% 
  group_by(nombre_estacion_origen,nombre_estacion_destino) %>% summarize(count = n()) %>% ungroup()

```

Vemos entonces que se hicieron 1091 viajes entre ambas estaciones, no es el viaje m치s hecho, pero si es uno bastante frecuente.

Apartado: Descubrimiento sobre el tiempo del recorrido
------------------------------------------------------

Dado que el punto solicita hacer un test de hip칩tesis sobre la duraci칩n del recorrido, buscamos comprobar que tan confiables eran los datos de 'duracion de recorrido' provisto por los datos.

```{r}

df$duracion_recorrido_manual <- as.numeric((df$fecha_destino_recorrido - df$fecha_origen_recorrido), units = 'secs')

ggplot(filter(df,(id_estacion_origen == 009) & (id_estacion_destino == 066))) + 
         geom_density(aes(x = duracion_recorrido_manual),fill = 'red', alpha = 0.3) +
         geom_density(aes(x = duracion_recorrido),fill = 'green', alpha = 0.3) +
         ggtitle('Distribucion de la duracion de los recorridos') + labs(x = 'Duracion de recorrido')
```

El grafico pareciera sugerir que ambas variables tienen medias distintas, por lo cual sospechamos que los datos provistos por el gobierno no est치n del todo acertados. Para confirmar las sospechas, realizamos un test de hip칩tesis.

```{r}

temp <- filter(df,(id_estacion_origen == 009) & (id_estacion_destino == 066) & (complete.cases(duracion_recorrido_manual)))

t.test(temp$duracion_recorrido,temp$duracion_recorrido_manual, paired = TRUE, alternative = 'two.sided')
```

Evidentemente, **ambas medidas no son iguales**. Puntualmente, la variable *'duracion_recorrido'* provista por el gobierno, difiere de la duracion calculada manualmente en 298 segundos (~ 5 minutos) por *debajo*.

En base a esta informaci칩n, se va a realizar el test de hip칩tesis sober la variable 'duracion_recorrido_manual', porque se entiende que es m치s confiable y qued칩 demostrado que es significativamente diferente del valor originalmente provisto.

Levantando las altas del 2018 y los recorridos del 2018:
```{r}
altas <- read.csv("usuarios-ecobici-2018.csv",
                  header = TRUE, sep = ",")

summary(altas)
dim(altas)
prop.table(table(altas$usuario_sexo))

recorridos <- read.csv("recorridos-realizados-2018.csv",
                       header = TRUE, sep = ",")

#Creo una columna que indique el dia de la semana en el que se retiro la bici.
recorridos$dia_semana <- as.factor(strftime(recorridos$fecha_origen_recorrido, "%A"))

summary(recorridos)
dim(recorridos)
prop.table(table(recorridos$genero_usuario))
prop.table(table(recorridos$dia_semana))
```
Respecto a las altas:
Vemos que en el 2018 se dieron de alta 56182 usuarios, de los cuales aproximadamente el 46% es femenino y el 54% masculino. El dia donde mas altas se dieron fue el 08/10/2018. La hora en la cual m硬 usuarios se dan de alta es a las 5:57:45. La edad promedio de los usuarios es de 33 a絪s.

Respecto a los recorridos:
Vemos que en el 2018 se hicieron 2619968 recorridos, que tanto el origen como el destino m硬 comun se da en la Facultad de Medicina y que las mujeres hicieron aproximadamente el 28% de los recorridos, mientras que los hombres el 72%. El d眼 de la semana en el que mas bicis son retiradas es el miercoles.


Punto dos
---------
```{r}
recorridos$fecha_origen_auxiliar <- as.factor(strptime(recorridos$fecha_origen_recorrido,
                                                       format = "%Y-%m-%d",
                                                       tz = "America/Argentina/Buenos_Aires"))
library("dplyr")
usuarios_diarios_a絪 <- recorridos %>% group_by(fecha_origen_auxiliar) %>% summarise(total = length(dia_semana)) %>% ungroup()
usuarios_diarios_a絪$total <- as.numeric(usuarios_diarios_a絪$total)
usuarios_diarios_a絪$dia_semana <- as.factor(strftime(usuarios_diarios_a絪$fecha_origen_auxiliar, "%A"))
tab <- usuarios_diarios_a絪 %>% group_by(dia_semana) %>% summarise(mu = mean(total)) %>% ungroup()
tab$z <- usuarios_diarios_a絪 %>% group_by(dia_semana) %>% summarise(mu = qt(0.975, length(total) - 1)) %>% ungroup()
tab$std <- usuarios_diarios_a絪 %>% group_by(dia_semana) %>% summarise(mu = sd(total)/sqrt(length(total))) %>% ungroup()
tab$lim_inf <- tab$mu - (tab$z$mu*tab$std$mu)
tab$lim_sup <- tab$mu + (tab$z$mu*tab$std$mu)

library("ggplot2")
tab$dia_semana <- factor(tab$dia_semana, levels = c("lunes","martes","mi本coles","jueves","viernes","s庚ado","domingo"))
grafIC <- ggplot(data = tab) + geom_pointrange(mapping = aes(x = dia_semana, y = mu, ymin = lim_inf, ymax = lim_sup)) + geom_errorbar(mapping = aes(x = dia_semana, ymin = lim_inf, ymax = lim_sup))

grafIC
```
En el gr擎ico que muestra los intervalos de confianza de la cantidad media de usuarios por cada dia de la semana encontramos evidencia estadistica de una estacionalidad en el uso de las bicis los dias de semana (lunes a viernes), donde vemos que los IC se solapan y son superiores a los de los dias de fin de semana (sabado y domingo).


Punto tres
----------
```{r}
feriados <- c("2018-01-01", "2018-02-12", "2018-02-13", "2018-03-24", "2018-03-29", "2018-03-30",
              "2018-04-02", "2018-04-30", "2018-05-01", "2018-05-25", "2018-06-17", "2018-06-20",
              "2018-07-09", "2018-08-20", "2018-09-15", "2018-10-19", "2018-12-08", "2018-12-24",
              "2018-12-25", "2018-12-31")
usuarios_diarios_a絪$es_feriado <- factor(ifelse(usuarios_diarios_a絪$fecha_origen_auxiliar %in% feriados,
                                                 1, 0))

tab <- usuarios_diarios_a絪 %>% filter(es_feriado == 0) %>% group_by(dia_semana) %>% summarise(mu = mean(total)) %>% ungroup()
tab$z <- usuarios_diarios_a絪 %>% filter(es_feriado == 0) %>% group_by(dia_semana) %>% summarise(mu = qt(0.975, length(total) - 1)) %>% ungroup()
tab$std <- usuarios_diarios_a絪 %>% filter(es_feriado == 0) %>% group_by(dia_semana) %>% summarise(mu = sd(total)/sqrt(length(total))) %>% ungroup()
tab$lim_inf <- tab$mu - (tab$z$mu*tab$std$mu)
tab$lim_sup <- tab$mu + (tab$z$mu*tab$std$mu)

tab$dia_semana <- factor(tab$dia_semana, levels = c("lunes","martes","mi本coles","jueves","viernes","s庚ado","domingo"))
grafIC_sin_feriados <- ggplot(data = tab) + geom_pointrange(mapping = aes(x = dia_semana, y = mu, ymin = lim_inf, ymax = lim_sup)) + geom_errorbar(mapping = aes(x = dia_semana, ymin = lim_inf, ymax = lim_sup))

grafIC_sin_feriados
```
Si descontamos del analisis los dias que fueron feriados vemos que la media de uso diario de bicis aumenta en general pero se mantiene la estacionalidad los dias de semana (lunes a viernes).


Punto 4
-------




Prueba de hip칩tesis
-------------------

**Hip칩tesis nula: La proporci칩n de usuarios que tardan mas de 15 minutos en hacer el recorrido de la estacion 009 a la 066 es mayor o igual al 20%.**

**Hip칩tesis alternativa: La proporci칩n de usuarios que tardan mas de 15 minutos en hacer el recorrido de la estacion 009 a la 066 es menor al 20%.**

Al tratarse de una proporci칩n, primero creamos una columna *booleana* para indicar si la duraci칩n del recorrido fue mayor o menor a 15 minutos.
A continuaci칩n, realizamos el test de hip칩tesi (con un nivel de significaci칩n del 5%).

```{r}
df$mas_15_min <- df$duracion_recorrido_manual > 15*60

subsample <- filter(df, complete.cases(duracion_recorrido_manual))

n = nrow(filter(subsample,id_estacion_origen == 009, id_estacion_destino == 066))

phat = nrow(filter(subsample,id_estacion_origen == 009, id_estacion_destino == 066,mas_15_min == TRUE))/ n

zstat = (phat-0.2)/sqrt(0.2*(1-0.2)/n)

zcrit = qt(0.05, df = n-1)

zstat;zcrit

pvalor <- pt(zstat,df=n-1,lower.tail=TRUE);pvalor
```

Tambien puede calcularse directamente con un binom.test:

```{r}

#df$mas_15_min <- df$duracion_recorrido_manual > 15*60

binom.test( x = nrow(filter(subsample,id_estacion_origen == 009, id_estacion_destino == 066,mas_15_min == TRUE)), 
            n = nrow(filter(subsample,id_estacion_origen == 009, id_estacion_destino == 066)), 
            p = 0.2, alternative = 'less')
```

El resultado del *p-value* es mayor 0.05, con lo cual, para un nivel de confianza del 95%, no tenemos evidencia suficiente para refutar la hip칩tesis nula. En otras palabras, no puedo rechazar la posibilidad de que la proporci칩n de usuarios que tardan m치s de 15 minutos es mayor al 20%


Evaluando la potencia del test
------------------------------

Ahora se eval칰a la *potencia* del test, osea, la probabilidad de rechazar la hip칩tesis nula, siendo esta falsa.


```{r}

pstar <- 0.19

xcrit <- qt(0.05, df = n-1)*sqrt((0.2*(1-0.2))/n)+0.2

zcrit <- (xcrit - pstar)/sqrt((pstar*(1 - pstar))/n)

beta <- 1 - pt(zcrit, df = n-1)

potencia <- 1 - beta; potencia

```

Con el resultado anterior, se obtuvo la potencia del test, ahora observamos que ocurre con la curva de potencia en la medida que variamos pstar:

````{r}



pstar <- seq(from = 0.1, to=0.2, by=0.001)

xcrit <- qt(0.05, df = n-1)*sqrt((0.2*(1-0.2))/n)+0.2

zcrit <- (xcrit - pstar)/sqrt((pstar*(1 - pstar))/n)

beta <- 1 - pt(zcrit, df = n-1)

potencia <- 1-beta

plot(pstar,potencia, ylim=c(0,1),type = "l", xlab= "mu*", ylab= "potencia", lwd=2)

```

Arriba se observa la curva de potencia para distintos valores de p estrella, se observa que para una un valor cercano al 20% como suger칤a el problema, la potencia del test es inferior al 20%. Se entiende entonces que la probabilidad de rechazar la hip칩tesis nula suponiendo que esta sea falsa es bastante baja.

A medida que suponemos que p estrella se corre hacia valores inferiores, vemos que la potencia del test sube significativamente con unos pocos corrimientos. Por lo tanto, cuanto m치s bajo sea el p estrella, m치s potente se vuelve el test porque la hip칩tesis nula original se volver칤a cada vez m치s absurda.



Punto 7
-------








Punto 8
--------









Punto 9
-------








Boostrapping
------------

Para poder hacer este punto, se necesita conocer la edad de los usuarios, cosa que el dataset de los recorridos no tiene. Debemos primero unir la base de id de usuarios (que si tiene la informaci칩n de la edad) con la de los recorridos.

```{r}


names(users)[1] <- 'id_usuario'

# Creo un nuevo dataframe con el merge entre la informacion de las bicicletas y la de los usuarios

df_with_users <- merge(x = df, y = users,by = 'id_usuario')
df_with_users <- select(df_with_users, -c(fecha_alta,hora_alta))

# Defino funcion de correlacion

fc_cor <- function(d,i){
  d <- df_with_users[i,]
  return(cor(d$duracion_recorrido,d$usuario_edad)) # Uso duracion de recorrido y no la manual porque tiene missings
}


set.seed(123) # Me aseguro poder replicar los mismos resultados a posteriori

boot_cor <- boot(data = filter(df_with_users,id_estacion_origen == 009, id_estacion_destino == 066), statistic = fc_cor, R = 10000)
boot_cor

#histograma y qqplot
plot(boot_cor)

#intervalo de confianza:
boot.ci(boot.out = boot_cor, type = c("norm", "basic", "perc", "bca"))

```